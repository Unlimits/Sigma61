C Файл PRNTDD.FOR
C Содержит подпрограмму PRNTDD(с выводом до 8000 строк)
C ================================================================
C Подпрограмма предназначена для вывода образа матрицы жесткости в 
C удобной для анализа форме:выводится только нижняя треугольная 
C матрица, причем символ '*' означает наличие ненулевого элемента 
C матрицы.    Вызывается из MAIN. Вызываемых модулей нет.
C =================================================================
! Разработчик модификации: Луняков А.В. 2011 г.
! Была добавлена возможность выводить матрицу не только в треугольном виде,
! но еще и в ленточном. Чтобы включить вывод в треугольном виде необходимо 
! отметить пункт 8 в конфигурировании комплекса. Для вывода матрицы в ленточном
! виде используется пункт 9. Треугольный вывод матрицы представляет собой
! нижний треугольник матрицы, а суть ленточного вывода состоит в том, что
! выводятся строки одинаковой длинны (равной максимальной ширине ленты),
! так, что самый правый элемент является диагональным. Тем самым, даже при
! больших размерностях матрицы все ненулевые элементы остаются сгрупированы
! у левой границы текстовых результатов, и их можно удобно просмотреть и оценить.
C ===================== начало кода PRNTDD ========================

      subroutine PRNTDD (NSTRT,NSTP,XENV,ENV,DIAG,IPR)

      INTEGER XENV,PROB/' '/,STR,NUL/'0'/,VAL/'*'/,LUN/0/
       DIMENSION ENV(1),DIAG(1),XENV(1),STR(8001),NIL(8001)
C      DIMENSION ENV(1),DIAG(1),XENV(1),STR(8001)
      LOGICAL*1 IPR(50)
       KI=0
  60   FORMAT(1X,'*',I4,8001A1)
  50   FORMAT(15X,'1',9X,'2',9X,'3',9X,'4',9X,'5',9X,'6',9X,'7',9X,'8',
     >9X,'9',9X,'0',9X,'1'/ 6X,11('1234567890'),'12345')
       KNSTRT=NSTRT   !номер первой строки
       KNSTP=NSTP     !номер последней строки(кол-во сттрок)
       LUN=0
111       KI=KI+1     !профиль=1, массив ENV=2  (начало 1ого из 2ух "тактов" подпрограммы)
       NSTRT=KNSTRT
       NSTP=KNSTP
      NSTOP=NSTP*1

         WRITE(6,70)
70     FORMAT(2X,'ВЫВОД MATPИЦЫ РАССЧИТАН НА 8000 CTOЛБЦOB') 
           
      IF(NSTOP-NSTRT.LE.8001) GO TO 500!если номер последней строки меньше номера первой
         NSTOP=NSTRT+8000

 500  WRITE(6,50)!печать верхней строки (номера столбцов)
       If (kI.EQ.1.and.IPR(8)) then
       print*,"Печать профиля в тругольном виде:"  
       endif
       If (kI.EQ.2.and.IPR(8)) then  
       print*,"Печать массива ENV в треугольном виде:"
       endif
       
 666   If (kI.EQ.1.and.IPR(9).and.lun.eq.1) then
       print*,"Печать профиля в ленточном виде:"  
       endif
       If (kI.EQ.2.and.IPR(9).and.lun.eq.3) then  
       print*,"Печать массива ENV в ленточном виде:"
       endif     
                 LUN=LUN+1
                 ILENTA=0
                 IZV=0
                 INUL=0
                 LOBOL=0
                
                
      K =0          
      DO 10 I=NSTRT,NSTOP!перебор номеров строк
      K=K+1              !К-тоже номер строки
      L=0
                  ISZV=0
                  ISNUL=0
                  ILOCLENTA=0
                  NNIL=0 
                   
      DO 20 J=NSTRT,I!перебор столбцов строки. чисто столбцов равно номеру строки(т.к. нижний треуг)
      L=L+1          !Л-номер столбца

      IF (I.EQ.J) GO TO 21!если последний элемент строки(диагональный)
      IVAL=XENV(I+1)-I+J!порядковый номер
  
      IF(IVAL.LT.XENV(I)) GO TO 22  !пока номер меньше того с которого начнется эта строка
      VALUE=ENV(IVAL)       !берем значение из массива элементов
           GO TO 23
 21   VALUE=DIAG(I)         !берем значение из массива диагональных элементов, если элемент последний в строке
       23   STR(L)=VAL    !предполагаем что он ненулевой
            IF(VALUE.NE.0) NNIL=1
                      IZV=IZV+1      !увеличиваем кол-во ненулевых
                      ISZV=ISZV+1
          IF(VALUE.EQ.0)then          !если элемент нулевой отменяем увеличение
          !и печатаем ноль(либо пробел)
                   If (kI.EQ.1)STR(L)=NUL     !был PROB
                   If (NNIL.EQ.0) STR(L)=PROB !убираем нули до первого ненул эл-та в строке
                   If (kI.EQ.2)   STR(L)=NUL 
                   IZV=IZV-1
                   ISZV=ISZV-1
          endif 
                
                 ILOCLENTA=ISZV+ISNUL      !число ненулевых в строке(ширина ленты?)
                                           !непонятно зачем +ISNUL=0 всегда
      GO TO 20
  22   STR(L)=PROB
  20   CONTINUE            
       !закончили заполнять строку идем дальше
        IF (kI.EQ.1) then       !запоминаем номер первого ненулевого элемента
        K15=NSTOP               
        DO 44 JJ=1,L            
        IF(STR(JJ).EQ.VAL)then  
         IF (JJ.LT.K15)then     
         K15=JJ                 
             endif
                 endif
        else K15=I             !иначе номер первого ненулевого равен диагональному
44     IILENTA=I-K15           !ширина ленты (номер последнего минус номер первого)
        endif
        IF (kI.EQ.2) then       !запоминаем номер первого ненулевого элемента
        K15=NSTOP
        DO 144 JJ=1,L
       IF(STR(JJ).EQ.VAL.OR.STR(JJ).EQ.NUL)then !значение "0" считается ненулевым
         IF (JJ.LT.K15)then
         K15=JJ
             endif
                 endif
        else K15=I
144     IILENTA=I-K15
         endif

         NIL(I)=IILENTA        !запоминаем локальную ширину ленты
       LOBOL=LOBOL+IILENTA     !размер оболочки считаем как сумму всех локальных ширин лент
                if(IILENTA.GT.ILENTA)then !отбираем максимальную ширину ленты
       ILENTA=IILENTA
       III=I                   !запоминаем строку в кот она встретилась впервые
               endif  
                  
       IF(IPR(9)) then
       if(LUN.eq.2.or.LUN.eq.4) then
        if(k.le.ILENTAMAX) then
           do n=1,k
              str(ILENTAMAX+n)=str(n)
              str(n)=PROB 
           enddo
           WRITE(6,60)I,(STR(J),J=k,k+ILENTAMAX)
        endif
        if(k.gt.ILENTAMAX) WRITE(6,60)I,(STR(J),J=K-ILENTAmax,K) 
        endif
       endif
       
       if(LUN.eq.1.or.LUN.eq.3) then
       if(IPR(8)) WRITE(6,60)I,(STR(J),J=1,K)
       endif
  10   CONTINUE  
         ILENTAMAX=ILENTA !запоминаем ширину ленту для последуйщего вывода
      if(LUN.eq.1.or.LUN.eq.3) goto 666
         if(kI.EQ.1)WRITE(6,61)IZV-I+1,LOBOL,ILENTA 
         if(kI.EQ.2)WRITE(6,64)IZV-I+1,LOBOL,ILENTA 
         DO 33 I=NSTRT,NSTOP
   33      if(NIL(I).EQ.ILENTA)WRITE(6,62)I 
         if(kI.LT.2) GO TO 111
  61   FORMAT(2X,'Всё без диаг: Ненулевых элементов в оболочке',I6/
     >2X,'размер оболочки матрицы',I8,/
     >2X,'максимальная ширина ленты матрицы',I8,2X,'в строках:')
  64   FORMAT(2X,'Всё без диаг: Ненулевых элементов в оболочке',I6/
     >2X,'размер хранимой оболочки',I8,/
     >2X,'максимальная ширина хранимой ленты',I8,2X,'в строках:')
C       WRITE(6,62) (NIL(I),I=1,NILNOMER)
   62   FORMAT(47X,I6)    
      RETURN
      END

C =================== конец кода PRNTDD ===========================
C =================================================================
C конец файла PRNTDD.FOR
